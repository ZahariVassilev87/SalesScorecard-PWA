const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const { Pool } = require('pg');
const crypto = require('crypto');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3000;

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  }
});

// JWT Secrets (use environment variables in production)
const JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret_key_for_access_tokens';
const REFRESH_SECRET = process.env.REFRESH_SECRET || 'your_refresh_secret_key_for_refresh_tokens';

// CORS configuration for production
app.use(cors({
  origin: [
    'https://d2tuhgmig1r5ut.cloudfront.net', // CloudFront domain
    'https://instorm.io', // Main domain
    'https://www.instorm.io', // WWW domain
    'http://localhost:3000' // Development
  ],
  credentials: true
}));

// Serve React Admin panel static files
app.use('/public-admin/react-admin', express.static('public/react-admin'));

// Serve entire public directory under /public-admin for auxiliary pages
app.use('/public-admin', express.static('public'));

// Serve admin-with-delete.html
app.get('/admin-with-delete.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'admin-with-delete.html'));
});

// Serve test-delete.html
app.get('/test-delete.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'test-delete.html'));
});

app.use(bodyParser.json());

// In-memory storage for evaluations (in production, use database)
let storedEvaluations = [];

// Authentication middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ message: 'No token provided', error: 'Unauthorized', statusCode: 401 });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      console.log('Token verification failed:', err.message);
      return res.status(403).json({ message: 'Forbidden', statusCode: 403 });
    }
    req.user = user;
    next();
  });
};

// Authorization middleware for evaluation creation
const authorizeEvaluationCreation = (req, res, next) => {
  const userRole = req.user.role;
  const allowedRoles = ['ADMIN', 'SALES_DIRECTOR', 'REGIONAL_SALES_MANAGER'];
  
  if (!allowedRoles.includes(userRole)) {
    return res.status(403).json({ 
      message: 'Insufficient permissions to create evaluations', 
      statusCode: 403 
    });
  }
  
  next();
};

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    message: 'Sales Scorecard API',
    version: '1.4.0',
    endpoints: [
      'POST /auth/login',
      'POST /auth/refresh',
      'POST /auth/logout',
      'POST /evaluations',
      'GET /evaluations/my',
      'GET /organizations/teams',
      'GET /organizations/salespeople',
      'GET /public-admin/teams',
      'GET /public-admin/users',
      'GET /users',
      'GET /scoring/categories',
      'GET /analytics/dashboard',
      'GET /analytics/team',
      'GET /health'
    ]
  });
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// Temporary endpoint to list all users (for debugging)
app.get('/debug/users', async (req, res) => {
  try {
    const result = await pool.query('SELECT id, email, "displayName", role, "isActive" FROM users ORDER BY email');
    res.json({
      message: 'All users in database',
      count: result.rows.length,
      users: result.rows.map(user => ({
        id: user.id,
        email: user.email,
        displayName: user.displayName,
        role: user.role,
        isActive: user.isActive
      }))
    });
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ 
      message: 'Database error', 
      error: error.message 
    });
  }
});

// Temporary endpoint to check for ADMIN users specifically
app.get('/debug/admin-users', async (req, res) => {
  try {
    const result = await pool.query('SELECT id, email, "displayName", role, "isActive" FROM users WHERE role = \'ADMIN\' ORDER BY email');
    res.json({
      message: 'Admin users in database',
      count: result.rows.length,
      users: result.rows.map(user => ({
        id: user.id,
        email: user.email,
        displayName: user.displayName,
        role: user.role,
        isActive: user.isActive
      }))
    });
  } catch (error) {
    console.error('Error fetching admin users:', error);
    res.status(500).json({ 
      message: 'Database error', 
      error: error.message 
    });
  }
});

// Temporary endpoint to create an admin user
app.post('/debug/create-admin', async (req, res) => {
  try {
    const { email, password, displayName } = req.body;
    
    if (!email || !password || !displayName) {
      return res.status(400).json({ 
        message: 'Email, password, and displayName are required' 
      });
    }

    // Hash the password
    const bcrypt = require('bcrypt');
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create admin user
    const result = await pool.query(
      'INSERT INTO users (id, email, password, "displayName", role, "isActive", "createdAt", "updatedAt") VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW()) RETURNING id, email, "displayName", role, "isActive"',
      [crypto.randomUUID(), email, hashedPassword, displayName, 'ADMIN', true]
    );

    res.json({
      message: 'Admin user created successfully',
      user: {
        id: result.rows[0].id,
        email: result.rows[0].email,
        displayName: result.rows[0].displayName,
        role: result.rows[0].role,
        isActive: result.rows[0].isActive
      }
    });
  } catch (error) {
    console.error('Error creating admin user:', error);
    res.status(500).json({ 
      message: 'Database error', 
      error: error.message 
    });
  }
});

// Simple endpoint to add admin user directly
app.get('/debug/add-admin', async (req, res) => {
  try {
    const bcrypt = require('bcrypt');
    const hashedPassword = await bcrypt.hash('test123', 10);
    
    // Insert admin user directly
    const result = await pool.query(
      'INSERT INTO users (id, email, password, "displayName", role, "isActive", "createdAt", "updatedAt") VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW()) RETURNING id, email, "displayName", role, "isActive"',
      ['cmfn0fwjb0001qpwtbk5fqnf2', 'vassilev.zahari@gmail.com', hashedPassword, 'Zahari Vassilev', 'ADMIN', true]
    );

    res.json({
      message: 'Admin user added successfully',
      user: result.rows[0]
    });
  } catch (error) {
    console.error('Error adding admin user:', error);
    res.status(500).json({ 
      message: 'Database error', 
      error: error.message 
    });
  }
});

// Endpoint to list files in container
app.get('/debug/list-files', async (req, res) => {
  try {
    const fs = require('fs');
    const path = require('path');
    
    const listFiles = (dir, prefix = '') => {
      const files = [];
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          files.push(prefix + item + '/');
          files.push(...listFiles(fullPath, prefix + item + '/'));
        } else {
          files.push(prefix + item);
        }
      }
      
      return files;
    };
    
    const files = listFiles('/app');
    res.json({ files: files.filter(f => f.includes('backup') || f.includes('.json')) });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Endpoint to setup database tables
app.get('/debug/setup-database', async (req, res) => {
  try {
    const results = {
      tables: 0,
      errors: []
    };
    
    // Create regions table
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS regions (
          id VARCHAR(255) PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          "createdAt" TIMESTAMP DEFAULT NOW(),
          "updatedAt" TIMESTAMP DEFAULT NOW()
        )
      `);
      results.tables++;
    } catch (error) {
      results.errors.push(`Regions table: ${error.message}`);
    }
    
    // Create teams table
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS teams (
          id VARCHAR(255) PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          "regionId" VARCHAR(255),
          "managerId" VARCHAR(255),
          "createdAt" TIMESTAMP DEFAULT NOW(),
          "updatedAt" TIMESTAMP DEFAULT NOW(),
          FOREIGN KEY ("regionId") REFERENCES regions(id),
          FOREIGN KEY ("managerId") REFERENCES users(id)
        )
      `);
      results.tables++;
    } catch (error) {
      results.errors.push(`Teams table: ${error.message}`);
    }
    
    // Create user_teams table
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS user_teams (
          id VARCHAR(255) PRIMARY KEY,
          "userId" VARCHAR(255) NOT NULL,
          "teamId" VARCHAR(255) NOT NULL,
          "createdAt" TIMESTAMP DEFAULT NOW(),
          "updatedAt" TIMESTAMP DEFAULT NOW(),
          FOREIGN KEY ("userId") REFERENCES users(id),
          FOREIGN KEY ("teamId") REFERENCES teams(id),
          UNIQUE("userId", "teamId")
        )
      `);
      results.tables++;
    } catch (error) {
      results.errors.push(`User_teams table: ${error.message}`);
    }
    
    res.json({
      message: 'Database setup completed',
      results: results
    });
  } catch (error) {
    console.error('Error setting up database:', error);
    res.status(500).json({ 
      message: 'Database setup error', 
      error: error.message 
    });
  }
});

// Endpoint to restore data manually
app.get('/debug/restore-data', async (req, res) => {
  try {
    const bcrypt = require('bcrypt');
    const results = {
      regions: 0,
      teams: 0,
      users: 0,
      errors: []
    };
    
    // Create sample regions
    try {
      const regions = [
        { id: 'region-1', name: 'North America' },
        { id: 'region-2', name: 'Europe' },
        { id: 'region-3', name: 'Asia Pacific' }
      ];
      
      for (const region of regions) {
        await pool.query(
          'INSERT INTO regions (id, name, "createdAt", "updatedAt") VALUES ($1, $2, NOW(), NOW()) ON CONFLICT (id) DO NOTHING',
          [region.id, region.name]
        );
        results.regions++;
      }
    } catch (error) {
      results.errors.push(`Regions: ${error.message}`);
    }
    
    // Create sample teams
    try {
      const teams = [
        { id: 'team-1', name: 'Enterprise Sales', regionId: 'region-1' },
        { id: 'team-2', name: 'SMB Sales', regionId: 'region-1' },
        { id: 'team-3', name: 'European Sales', regionId: 'region-2' },
        { id: 'team-4', name: 'APAC Sales', regionId: 'region-3' }
      ];
      
      for (const team of teams) {
        await pool.query(
          'INSERT INTO teams (id, name, "regionId", "createdAt", "updatedAt") VALUES ($1, $2, $3, NOW(), NOW()) ON CONFLICT (id) DO NOTHING',
          [team.id, team.name, team.regionId]
        );
        results.teams++;
      }
    } catch (error) {
      results.errors.push(`Teams: ${error.message}`);
    }
    
    // Create sample users
    try {
      const users = [
        { id: 'user-1', email: 'john.doe@company.com', displayName: 'John Doe', role: 'SALESPERSON', password: 'password123' },
        { id: 'user-2', email: 'jane.smith@company.com', displayName: 'Jane Smith', role: 'SALES_LEAD', password: 'password123' },
        { id: 'user-3', email: 'mike.johnson@company.com', displayName: 'Mike Johnson', role: 'REGIONAL_SALES_MANAGER', password: 'password123' },
        { id: 'user-4', email: 'sarah.wilson@company.com', displayName: 'Sarah Wilson', role: 'SALES_DIRECTOR', password: 'password123' },
        { id: 'user-5', email: 'david.brown@company.com', displayName: 'David Brown', role: 'SALESPERSON', password: 'password123' }
      ];
      
      for (const user of users) {
        const hashedPassword = await bcrypt.hash(user.password, 10);
        
        await pool.query(
          'INSERT INTO users (id, email, password, "displayName", role, "isActive", "createdAt", "updatedAt") VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW()) ON CONFLICT (id) DO NOTHING',
          [user.id, user.email, hashedPassword, user.displayName, user.role, true]
        );
        results.users++;
      }
    } catch (error) {
      results.errors.push(`Users: ${error.message}`);
    }
    
    res.json({
      message: 'Sample data created successfully',
      results: results
    });
  } catch (error) {
    console.error('Error creating sample data:', error);
    res.status(500).json({ 
      message: 'Database error', 
      error: error.message 
    });
  }
});

// Authentication routes
app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  console.log('Login attempt:', { email, password: '***' });

  try {
    // First, let's check what schemas exist in the database
    const schemasInfo = await pool.query(`
      SELECT schema_name 
      FROM information_schema.schemata 
      WHERE schema_name NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
      ORDER BY schema_name
    `);
    console.log('Available schemas in database:', schemasInfo.rows);
    
    // Check what tables exist in all schemas
    const tablesInfo = await pool.query(`
      SELECT table_schema, table_name 
      FROM information_schema.tables 
      WHERE table_schema NOT IN ('information_schema', 'pg_catalog', 'pg_toast')
      ORDER BY table_schema, table_name
    `);
    console.log('Available tables in all schemas:', tablesInfo.rows);
    
    // Check if there are any tables that might contain user data
    const userTablesInfo = await pool.query(`
      SELECT table_schema, table_name 
      FROM information_schema.tables 
      WHERE table_name ILIKE '%user%' OR table_name ILIKE '%account%' OR table_name ILIKE '%member%'
      ORDER BY table_schema, table_name
    `);
    console.log('Tables that might contain user data:', userTablesInfo.rows);
    
    // Check what columns exist in the users table
    const usersTableInfo = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'users' 
      ORDER BY ordinal_position
    `);
    console.log('Available columns in users table:', usersTableInfo.rows);
    
    // Check current database name
    const dbInfo = await pool.query(`SELECT current_database(), current_schema()`);
    console.log('Current database and schema:', dbInfo.rows[0]);
    
    // Check if there are other databases we can connect to
    const otherDbsInfo = await pool.query(`
      SELECT datname 
      FROM pg_database 
      WHERE datistemplate = false AND datname NOT IN ('postgres', 'template0', 'template1')
      ORDER BY datname
    `);
    console.log('Other available databases:', otherDbsInfo.rows);
    
    const result = await pool.query(
      'SELECT id, email, password, role, "displayName", "isActive" FROM users WHERE email = $1 AND "isActive" = true',
      [email]
    );

    if (result.rows.length === 0) {
      return res.status(401).json({ 
        message: 'Invalid email or password', 
        error: 'Unauthorized', 
        statusCode: 401 
      });
    }

    const user = result.rows[0];
    
    // Use bcrypt to compare hashed password
    const bcrypt = require('bcrypt');
    const isPasswordValid = await bcrypt.compare(password, user.password);
    
    if (!isPasswordValid) {
      return res.status(401).json({ 
        message: 'Invalid email or password', 
        error: 'Unauthorized', 
        statusCode: 401 
      });
    }

    const token = jwt.sign(
      { 
        id: user.id, 
        email: user.email, 
        role: user.role,
        displayName: user.displayName 
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    const refreshToken = jwt.sign(
      { id: user.id, email: user.email },
      REFRESH_SECRET,
      { expiresIn: '7d' }
    );

    console.log('Login successful for user:', user.email);

    res.json({
      token,
      refreshToken,
      user: {
        id: user.id,
        email: user.email,
        displayName: user.displayName,
        role: user.role,
        isActive: user.isActive
      }
    });
  } catch (error) {
    console.error('Database error during login:', error);
    res.status(500).json({ 
      message: 'Internal server error', 
      error: 'DatabaseError', 
      statusCode: 500 
    });
  }
});

app.post('/auth/refresh', (req, res) => {
  const { refreshToken } = req.body;
  console.log('Refresh token request');

  if (!refreshToken) {
    return res.status(401).json({ message: 'No refresh token provided' });
  }

  jwt.verify(refreshToken, REFRESH_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Invalid refresh token' });
    }

    const newToken = jwt.sign(
      { 
        id: user.id, 
        email: user.email, 
        role: 'REGIONAL_SALES_MANAGER',
        displayName: 'User' 
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({ token: newToken });
  });
});

app.post('/auth/logout', (req, res) => {
  console.log('Logout request');
  res.json({ message: 'Logged out successfully' });
});

// Evaluation routes
app.post('/evaluations', authenticateToken, authorizeEvaluationCreation, (req, res) => {
  console.log('Evaluation creation request from user:', req.user.email);
  console.log('Evaluation data:', req.body);
  
  const evaluationId = `eval_${Date.now()}`;
  const evaluation = {
    id: evaluationId,
    salespersonId: req.body.salespersonId,
    salesperson: {
      id: req.body.salespersonId,
      name: 'Maria', // This would come from the salespeople data in a real app
      email: 'maria@company.com'
    },
    managerId: req.user.id,
    manager: {
      id: req.user.id,
      name: req.user.displayName || 'Regional Manager',
      email: req.user.email
    },
    visitDate: req.body.visitDate,
    customerName: req.body.customerName || 'Unknown Customer',
    customerType: req.body.customerType || 'unknown',
    location: req.body.location || 'Unknown Location',
    overallComment: req.body.overallComment || '',
    overallScore: calculateOverallScore(req.body.items),
    items: req.body.items.map((item, index) => ({
      id: `item_${evaluationId}_${index}`,
      behaviorItemId: item.behaviorItemId,
      behaviorItem: {
        id: item.behaviorItemId,
        name: getBehaviorItemName(item.behaviorItemId),
        category: { name: 'Coaching' }
      },
      rating: item.score,
      comment: item.comment || ''
    })),
    version: 1,
    createdAt: new Date().toISOString()
  };
  
  storedEvaluations.push(evaluation);
  console.log(`âœ… Stored evaluation ${evaluationId} for user ${req.user.email}`);
  console.log(`ðŸ“Š Total evaluations stored: ${storedEvaluations.length}`);
  
  res.status(201).json({ 
    message: 'Evaluation created successfully', 
    id: evaluationId,
    data: req.body
  });
});

app.get('/evaluations/my', authenticateToken, (req, res) => {
  console.log('My evaluations request from user:', req.user.email);
  
  const userEvaluations = storedEvaluations.filter(eval => eval.managerId === req.user.id);
  console.log(`Found ${userEvaluations.length} evaluations for user ${req.user.email}`);
  
  res.json(userEvaluations);
});

// Organization routes
app.get('/organizations/teams', authenticateToken, (req, res) => {
  console.log('Organizations teams request from user:', req.user.email, 'role:', req.user.role);
  
  // Return empty array for now - this should be handled by your existing admin panel
  // The frontend should be calling the original /public-admin/teams endpoint
  res.json([]);
});

app.get('/organizations/salespeople', authenticateToken, async (req, res) => {
  console.log('Organizations salespeople request from user:', req.user.email, 'role:', req.user.role);
  
  try {
           let query = `
             SELECT u.id, u.email, u."displayName", u.role, u."isActive",
                    t.id as team_id, t.name as team_name
             FROM users u
             LEFT JOIN user_teams ut ON u.id = ut.user_id
             LEFT JOIN teams t ON ut.team_id = t.id
             WHERE u."isActive" = true AND u.role IN ('SALESPERSON', 'SALES_LEAD')
           `;
    
    let params = [];
    
    if (req.user.role === 'REGIONAL_SALES_MANAGER') {
      query += ` AND ut.team_id IN (
        SELECT ut2.team_id FROM user_teams ut2 
        WHERE ut2.user_id = $1 AND ut2.role = 'MANAGER'
      )`;
      params.push(req.user.id);
    } else if (req.user.role === 'SALESPERSON') {
      query += ` AND u.id = $1`;
      params.push(req.user.id);
    }
    
    const result = await pool.query(query, params);
    
    const salespeople = result.rows.map(row => ({
      id: row.id,
      email: row.email,
      displayName: row.displayName,
      role: row.role,
      isActive: row.isActive,
      teamId: row.team_id,
      teamName: row.team_name
    }));
    
    console.log(`Returning ${salespeople.length} salespeople for user ${req.user.email}`);
    res.json(salespeople);
  } catch (error) {
    console.error('Database error fetching salespeople:', error);
    res.status(500).json({ 
      message: 'Internal server error', 
      error: 'DatabaseError', 
      statusCode: 500 
    });
  }
});

// Public admin routes (fallback)
app.get('/public-admin/teams', authenticateToken, async (req, res) => {
  console.log('Public admin teams request from user:', req.user.email);
  
  try {
    // Ensure tables exist
    await pool.query(`
      CREATE TABLE IF NOT EXISTS teams (
        id VARCHAR(255) PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        "regionId" VARCHAR(255),
        "managerId" VARCHAR(255),
        "createdAt" TIMESTAMP DEFAULT NOW(),
        "updatedAt" TIMESTAMP DEFAULT NOW()
      )
    `);
    await pool.query(`
      CREATE TABLE IF NOT EXISTS user_teams (
        id VARCHAR(255) PRIMARY KEY,
        "userId" VARCHAR(255) NOT NULL,
        "teamId" VARCHAR(255) NOT NULL,
        "createdAt" TIMESTAMP DEFAULT NOW(),
        "updatedAt" TIMESTAMP DEFAULT NOW(),
        UNIQUE("userId", "teamId")
      )
    `);

    // Fetch teams
    const teamsResult = await pool.query(`
      SELECT t.id, t.name, t."regionId", t."managerId", t."createdAt", t."updatedAt",
             mu.id as mgr_id, mu.email as mgr_email, mu."displayName" as mgr_name, mu.role as mgr_role
      FROM teams t
      LEFT JOIN users mu ON mu.id = t."managerId"
      ORDER BY t.name
    `);

    const teamIds = teamsResult.rows.map(r => r.id);

    // Fetch user-team memberships
    let memberships = [];
    if (teamIds.length > 0) {
      const mt = await pool.query(`
        SELECT ut."teamId", u.id as user_id, u.email, u."displayName", u.role, u."isActive"
        FROM user_teams ut
        JOIN users u ON u.id = ut."userId"
        WHERE ut."teamId" = ANY($1)
      `, [teamIds]);
      memberships = mt.rows;
    }

    // Group memberships by team
    const teamIdToMembers = new Map();
    for (const row of memberships) {
      if (!teamIdToMembers.has(row.teamId)) teamIdToMembers.set(row.teamId, []);
      teamIdToMembers.get(row.teamId).push({
        user: {
          id: row.user_id,
          email: row.email,
          displayName: row.displayName,
          role: row.role,
          isActive: row.isActive
        }
      });
    }

    const teams = teamsResult.rows.map(row => ({
      id: row.id,
      name: row.name,
      region: row.regionId ? { name: row.regionId } : null,
      manager: row.managerId ? {
        id: row.mgr_id,
        email: row.mgr_email,
        displayName: row.mgr_name,
        role: row.mgr_role
      } : null,
      managerId: row.managerId,
      userTeams: teamIdToMembers.get(row.id) || []
    }));

    console.log(`Returning ${teams.length} teams with members for admin panel`);
    res.json(teams);
  } catch (error) {
    console.error('Error fetching teams:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

app.get('/public-admin/users', authenticateToken, async (req, res) => {
  console.log('Public admin users request from user:', req.user.email);
  
  try {
    // Simple query that works with current database schema
    const result = await pool.query(`
      SELECT id, email, "displayName", role, "isActive", "createdAt", "updatedAt"
      FROM users
      WHERE "isActive" = true
      ORDER BY "displayName", email
    `);
    
    const users = result.rows.map(row => ({
      id: row.id,
      email: row.email,
      displayName: row.displayName,
      role: row.role,
      isActive: row.isActive,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt,
      teamId: null,
      teamName: null,
      teamRole: null
    }));
    
    console.log(`Returning ${users.length} users for admin panel`);
    res.json(users);
  } catch (error) {
    console.error('Database error fetching users:', error);
    res.status(500).json({ 
      message: 'Internal server error', 
      error: 'DatabaseError', 
      statusCode: 500 
    });
  }
});

// User routes
app.get('/users', authenticateToken, (req, res) => {
  console.log('Users request from user:', req.user.email);
  // TODO: Connect to your real admin panel to get users data
  res.json([]);
});

// Scoring categories
app.get('/scoring/categories', authenticateToken, (req, res) => {
  console.log('Scoring categories request from user:', req.user.email);
  res.json([
    {
      id: 'coaching',
      name: 'Coaching',
      order: 1,
      weight: 1.0,
      items: [
        { id: 'coaching-1', name: 'Active Listening', order: 1, weight: 1.0 },
        { id: 'coaching-2', name: 'Questioning Skills', order: 2, weight: 1.0 },
        { id: 'coaching-3', name: 'Feedback Delivery', order: 3, weight: 1.0 },
        { id: 'coaching-4', name: 'Goal Setting', order: 4, weight: 1.0 },
        { id: 'coaching-5', name: 'Follow-up', order: 5, weight: 1.0 }
      ]
    }
  ]);
});

// Analytics routes
app.get('/analytics/dashboard', authenticateToken, (req, res) => {
  console.log('Dashboard analytics request from user:', req.user.email);
  res.json({
    totalEvaluations: storedEvaluations.length,
    averageScore: storedEvaluations.length > 0 ? 
      storedEvaluations.reduce((sum, eval) => sum + eval.overallScore, 0) / storedEvaluations.length : 0,
    evaluationsThisMonth: storedEvaluations.filter(eval => {
      const evalDate = new Date(eval.createdAt);
      const now = new Date();
      return evalDate.getMonth() === now.getMonth() && evalDate.getFullYear() === now.getFullYear();
    }).length
  });
});

app.get('/analytics/team', authenticateToken, (req, res) => {
  console.log('Team analytics request from user:', req.user.email);
  res.json({
    teamEvaluations: storedEvaluations.filter(eval => eval.managerId === req.user.id),
    teamAverageScore: 0 // Calculate based on team evaluations
  });
});

// Helper functions
function calculateOverallScore(items) {
  if (!items || items.length === 0) return 0;
  const totalScore = items.reduce((sum, item) => sum + (item.score || 0), 0);
  return Math.round((totalScore / items.length) * 100) / 100;
}

function getBehaviorItemName(itemId) {
  const items = {
    'coaching-1': 'Active Listening',
    'coaching-2': 'Questioning Skills',
    'coaching-3': 'Feedback Delivery',
    'coaching-4': 'Goal Setting',
    'coaching-5': 'Follow-up'
  };
  return items[itemId] || 'Unknown Item';
}

// Start server
app.listen(PORT, () => {
  console.log(`ðŸš€ Production backend server running on port ${PORT}`);
  console.log('ðŸ“‹ Available endpoints:');
  console.log('  POST /auth/login - Login with email/password');
  console.log('  POST /auth/refresh - Refresh access token');
  console.log('  POST /auth/logout - Logout and invalidate refresh token');
  console.log('  POST /evaluations - Create evaluation (requires auth)');
  console.log('  GET /evaluations/my - Get my evaluations (requires auth)');
  console.log('  GET /organizations/teams - Get teams (requires auth)');
  console.log('  GET /organizations/salespeople - Get salespeople (requires auth)');
  console.log('  GET /public-admin/teams - Get all teams (requires auth)');
  console.log('  GET /public-admin/users - Get all users (requires auth)');
  console.log('  POST /public-admin/users - Create user (requires auth)');
  console.log('  PUT /public-admin/users/:id - Update user (requires auth)');
  console.log('  POST /public-admin/users/:id/deactivate - Deactivate user (requires auth)');
  console.log('  DELETE /public-admin/users/:id - Delete user (requires auth)');
  console.log('  GET /users - Get all users (requires auth)');
  console.log('  GET /scoring/categories - Get scoring categories (requires auth)');
  console.log('  GET /analytics/dashboard - Get dashboard analytics (requires auth)');
  console.log('  GET /analytics/team - Get team analytics (requires auth)');
  console.log('  GET /health - Health check');
  console.log('  GET /public-admin/react-admin - React Admin panel');
  console.log('ðŸ”‘ Using real database authentication');
  console.log('  Connect to your PostgreSQL database using DATABASE_URL');
  console.log('  All endpoints now return real data from your database');
});

// Additional admin panel endpoints
app.get('/public-admin/regions', authenticateToken, async (req, res) => {
  try {
    // For now, return default regions since the regions table doesn't exist
    const defaultRegions = [
      { id: 'north-america', name: 'North America' },
      { id: 'europe', name: 'Europe' },
      { id: 'asia-pacific', name: 'Asia Pacific' },
      { id: 'latin-america', name: 'Latin America' }
    ];
    res.json(defaultRegions);
  } catch (error) {
    console.error('Error fetching regions:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

// Setup teams table endpoint
app.get('/debug/setup-teams-table', authenticateToken, async (req, res) => {
  try {
        await pool.query(`
          CREATE TABLE IF NOT EXISTS teams (
            id VARCHAR(255) PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            "regionId" VARCHAR(255),
            "managerId" VARCHAR(255),
            "createdAt" TIMESTAMP DEFAULT NOW(),
            "updatedAt" TIMESTAMP DEFAULT NOW()
          )
        `);
    
    res.json({ message: 'Teams table created successfully' });
  } catch (error) {
    console.error('Error creating teams table:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

// User management endpoints
app.post('/public-admin/users', authenticateToken, async (req, res) => {
  try {
    const { displayName, email, password, role } = req.body;
    const bcrypt = require('bcrypt');
    const hashedPassword = await bcrypt.hash(password, 10);
    
    const result = await pool.query(
      'INSERT INTO users (id, email, password, "displayName", role, "isActive", "createdAt", "updatedAt") VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW()) RETURNING id, email, "displayName", role, "isActive"',
      [crypto.randomUUID(), email, hashedPassword, displayName, role, true]
    );
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error creating user:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

app.put('/public-admin/users/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { displayName, email, role, isActive } = req.body;
    
    const result = await pool.query(
      'UPDATE users SET "displayName" = $1, email = $2, role = $3, "isActive" = $4, "updatedAt" = NOW() WHERE id = $5 RETURNING id, email, "displayName", role, "isActive"',
      [displayName, email, role, isActive, id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error updating user:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

app.post('/public-admin/users/:id/deactivate', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(
      'UPDATE users SET "isActive" = false, "updatedAt" = NOW() WHERE id = $1 RETURNING id, email, "displayName", role, "isActive"',
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error deactivating user:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

app.delete('/public-admin/users/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    // First check if user exists
    const checkResult = await pool.query('SELECT id, email, "displayName" FROM users WHERE id = $1', [id]);
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    const user = checkResult.rows[0];
    
    // Delete the user
    const result = await pool.query('DELETE FROM users WHERE id = $1', [id]);
    
    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json({ 
      message: 'User deleted successfully',
      deletedUser: {
        id: user.id,
        email: user.email,
        displayName: user.displayName
      }
    });
  } catch (error) {
    console.error('Error deleting user:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

// Team management endpoints
app.post('/public-admin/teams', authenticateToken, async (req, res) => {
  try {
    const { name, region, managerId } = req.body;
    
    // First, ensure the teams table exists
        await pool.query(`